material {
	name : %NAME%,
#option RefractionType
#variant Thin
	constants : [
		{
			type : float,
			name : surface_thickness
		}
	],
#endoption
	parameters : [
		{
			type : sampler2d,
			name : color_map
		}
		,
		{
			type : sampler2d,
			name : at_map
		}
#if Normals
		,
		{
			type : sampler2d,
			name : normal_map
		}
#endif Normals
#if Orm
		,
		{
			type : sampler2d,
			name : orm_map
		}
#endif Orm
#if Emissive
		,
		{
			type : sampler2d,
			name : emissive_map
		}
#endif Emissive
#if Anisotropy
		,
		{
			type : sampler2d,
			name : anisotropy_map
		}
#endif Anisotropy
	],
	requires : [
		uv0
	],
	shadingModel : lit,
	flipUV : false,
	blending : masked,
#option RefractionQuality
#variant Disabled
	refractionMode : none,
	reflections : default,
#variant Low
	refractionMode : cubemap,
	reflections : default,
#variant High
	refractionMode : screenspace,
	reflections : screenspace,
#endoption
#option RefractionType
#variant Thin
	refractionType : thin
#variant Thick
	refractionType : solid
#endoption
}

fragment {
	void material(inout MaterialInputs material) {
		vec2 uv0 = getUV0();

#if Normals
		material.normal = texture(materialParams_normal_map, uv0).xyz * 2.0 - 1.0;
		material.normal.y = -material.normal.y;
#endif Normals

		prepareMaterial(material);

		material.baseColor.rgba = texture(materialParams_color_map, uv0).rgba;

#if Orm
		material.ambientOcclusion = texture(materialParams_orm_map, uv0).r;
		material.roughness = texture(materialParams_orm_map, uv0).g;
		material.metallic = texture(materialParams_orm_map, uv0).b;
#option OrmReflectance
#variant Off
#variant On
		material.reflectance = texture(materialParams_orm_map, uv0).a;
#endoption
#endif Orm
	}
}