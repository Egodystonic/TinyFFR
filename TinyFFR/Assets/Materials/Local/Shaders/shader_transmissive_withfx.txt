material {
	name : %NAME%,
	featureLevel : 3,
	parameters : [
		{
			type : float4x4,
			name : uv_transform
		},
		{
			type : sampler2d,
			name : color_map
		},
		{
			type : sampler2d,
			name : color_map_blend
		},
		{
			type : float,
			name : color_map_blend_distance
		}
		,
		{
			type : sampler2d,
			name : at_map
		},
		{
			type : sampler2d,
			name : at_map_blend
		},
		{
			type : float,
			name : at_map_blend_distance
		},
		{
			type : float,
			name : surface_thickness
		}
#if Normals
		,
		{
			type : sampler2d,
			name : normal_map
		}
#endif Normals
#if Orm
		,
		{
			type : sampler2d,
			name : orm_map
		},
		{
			type : sampler2d,
			name : orm_map_blend
		},
		{
			type : float,
			name : orm_map_blend_distance
		}
#endif Orm
#if Emissive
		,
		{
			type : sampler2d,
			name : emissive_map
		},
		{
			type : sampler2d,
			name : emissive_map_blend
		},
		{
			type : float,
			name : emissive_map_blend_distance
		}
#endif Emissive
#if Anisotropy
		,
		{
			type : sampler2d,
			name : anisotropy_map
		}
#endif Anisotropy
	],
	requires : [
		uv0
	],
	shadingModel : lit,
	flipUV : false,
#option AlphaMode
#variant AlphaOff
	blending : opaque,
#variant AlphaOn
	blending : masked,
#variant AlphaOnBlended
	blending : fade,
#endoption
#option RefractionQuality
#variant Low
	refractionMode : cubemap,
	reflections : default,
#variant High
	refractionMode : screenspace,
	reflections : screenspace,
#endoption
#option RefractionType
#variant Thin
	refractionType : thin
#variant Thick
	refractionType : solid
#endoption
}

fragment {
	void material(inout MaterialInputs material) {
		float3 uv0Extended = float3(getUV0().xy, 1.0);
		vec2 uv0 = mulMat3x3Float3(materialParams.uv_transform, uv0Extended).xy;

#if Normals
		material.normal = texture(materialParams_normal_map, uv0).xyz * 2.0 - 1.0;
		material.normal.y = -material.normal.y;
#endif Normals

		prepareMaterial(material);

#option AlphaMode
#variant AlphaOff
		vec3 startColor = texture(materialParams_color_map, uv0).rgb;
		vec3 endColor = texture(materialParams_color_map_blend, uv0).rgb;
		material.baseColor.rgb = startColor * (1.0f - materialParams.color_map_blend_distance) + endColor * materialParams.color_map_blend_distance;
#variant AlphaOn
		vec4 startColor = texture(materialParams_color_map, uv0).rgba;
		vec4 endColor = texture(materialParams_color_map_blend, uv0).rgba;
		material.baseColor.rgba = startColor * (1.0f - materialParams.color_map_blend_distance) + endColor * materialParams.color_map_blend_distance;
#variant AlphaOnBlended
		vec4 startColor = texture(materialParams_color_map, uv0).rgba;
		vec4 endColor = texture(materialParams_color_map_blend, uv0).rgba;
		material.baseColor.rgba = startColor * (1.0f - materialParams.color_map_blend_distance) + endColor * materialParams.color_map_blend_distance;
#endoption

#if Orm
		vec4 startOrmr = texture(materialParams_orm_map, uv0).rgba;
		vec4 endOrmr = texture(materialParams_orm_map_blend, uv0).rgba;
		vec4 ormr = startOrmr * (1.0f - materialParams.orm_map_blend_distance) + endOrmr * materialParams.orm_map_blend_distance;
		material.ambientOcclusion = ormr.r;
		material.roughness = ormr.g;
		material.metallic = ormr.b;
		material.reflectance = ormr.a;
#endif Orm

#if Emissive
		vec4 startEmissive = texture(materialParams_emissive_map, uv0).rgba;
		vec4 endEmissive = texture(materialParams_emissive_map_blend, uv0).rgba;

		vec4 emissive = startEmissive * (1.0f - materialParams.emissive_map_blend_distance) + endEmissive * materialParams.emissive_map_blend_distance;
		material.emissive.rgb = emissive.rgb * (100.0 * emissive.a);
		material.emissive.a = 0.05;
#endif Emissive

#if Anisotropy
		vec3 anisotropy = texture(materialParams_anisotropy_map, uv0).rgb;
		material.anisotropyDirection = vec3(anisotropy.rg * 2.0 - 1.0, 0.0);
		material.anisotropy = anisotropy.b;
#endif Anisotropy

		vec4 startAt = texture(materialParams_at_map, uv0).rgba;
		vec4 endAt = texture(materialParams_at_map_blend, uv0).rgba;

		vec4 at = startAt * (1.0f - materialParams.at_map_blend_distance) + endAt * materialParams.at_map_blend_distance;
		material.absorption = at.rgb;
		material.transmission = at.a;
#option RefractionType
#variant Thin
		material.microThickness = materialParams.surface_thickness;
#variant Thick
		material.thickness = materialParams.surface_thickness;
#endoption
	}
}