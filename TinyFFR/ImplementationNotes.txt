Parameter Checking / Validation:
	General philosophy is to parameter validate/check where the branching + checking will not dwarf the runtime cost of the method or where the check provides significant protection against programming errors.
	A starting rule-of-thumb is that if the method is inlinable we should consider skipping parameter validation.
		However, this isn't always the case-- for example if the actual function body still invokes something costly or if the function is not expected to be called often, it's probably still worth validating.
		Also, when a method is easy to make mistakes with, it's still worth considering a parameter validation even if it might be detrimental to the performance of it; 
		ultimately this library is meant to eschew some performance for the sake of user-friendliness. People seeking every last CPU cycle can write their own DX/OGL/Vulkan/Metal wrapper.
	Overall, the idea is that by validating wherever possible we can hopefully balance helping users catch mistakes without sacrificing performance.

Overloaded Operators:
	% operator creates rotations
	^ operator creates angles
	* and / operator scales things
	+ operator combines things
	>>/<< operators return something that represents the transition between the two operands

	Chose ^ for angles because it looks like an angle
	Chose % for rotations because:
		It has higher precedence (avoids annoying things like having to parenthesize `someRot == 90f % Direction.Up` instead of e.g. using a bitwise operator)
		It's a better fit than any of the other binary overloadable operators IMO (though it's still not perfect)
		It kind of looks like the top right of a clock face with the minute hand between two numbers?

The factory is the "root" object of everything and acts as a pseudo-DI/lookup provider for everything else while allowing us to effectively unit test.
Loaders tell TinyFFR how to load files to make RamResourceHandles.
Builders tell TinyFFR how to build RamResourceHandles programmatically.
A RamResourceHandle can then be transferred to VRAM to get hold of a VramResourceHandle, optionally unloading the RAM resource in the same moment (to free up RAM)
Most of the time, 

... Actually, take above idea but instead streamline it in to RamLoaders and VramLoaders. Default is VramLoader, but let users load in to Ram for more advanced scenarios where they wanna stage resources .
No, just have loaders that by default return a non-ram resource (no prefix), but let people have the option. With a RamResource they can transfer manually.